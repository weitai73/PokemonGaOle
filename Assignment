package assignmentoop;

import javax.swing.*;
import java.util.*;
import java.io.*;
import java.util.List;

public class PokemonGame {

    private static Player player;
    private static String currentLocation;
    private static int coins;
    private static final Random random = new Random();
    private static final Scanner scanner = new Scanner(System.in);
    private static final String SCORES_FILE = "scores.txt";
    private static final String SAVE_FILE = "player_data.data";

    // Pokemon database with base stats and rarity
    private static final Map<String, PokemonData> POKEMON_DB = new HashMap<>();
    private static final Map<String, Integer> POKEMON_RARITY = new HashMap<>();

    static {
        initializePokemonDatabase();
    }

    private static void initializePokemonDatabase() {
        // Electric
        POKEMON_DB.put("Pikachu", new PokemonData(PokemonType.ELECTRIC, 10, 0.3, 35, 55, 40, 90));
        POKEMON_RARITY.put("Pikachu", 3);

        // Fire
        POKEMON_DB.put("Charmander", new PokemonData(PokemonType.FIRE, 12, 0.2, 39, 52, 43, 65));
        POKEMON_RARITY.put("Charmander", 2);
        POKEMON_DB.put("Ponyta", new PokemonData(PokemonType.FIRE, 12, 0.25, 50, 85, 55, 90));
        POKEMON_RARITY.put("Ponyta", 3);
        POKEMON_DB.put("Growlithe", new PokemonData(PokemonType.FIRE, 11, 0.3, 55, 70, 45, 60));
        POKEMON_RARITY.put("Growlithe", 2);

        // Water
        POKEMON_DB.put("Squirtle", new PokemonData(PokemonType.WATER, 11, 0.2, 44, 48, 65, 43));
        POKEMON_RARITY.put("Squirtle", 2);
        POKEMON_DB.put("Psyduck", new PokemonData(PokemonType.WATER, 11, 0.3, 50, 52, 48, 55));
        POKEMON_RARITY.put("Psyduck", 3);
        POKEMON_DB.put("Poliwag", new PokemonData(PokemonType.WATER, 10, 0.4, 40, 50, 40, 90));
        POKEMON_RARITY.put("Poliwag", 2);
        POKEMON_DB.put("Magikarp", new PokemonData(PokemonType.WATER, 5, 0.8, 20, 10, 55, 80));
        POKEMON_RARITY.put("Magikarp", 1);

        // Grass
        POKEMON_DB.put("Bulbasaur", new PokemonData(PokemonType.GRASS, 10, 0.2, 45, 49, 49, 45));
        POKEMON_RARITY.put("Bulbasaur", 2);
        POKEMON_DB.put("Oddish", new PokemonData(PokemonType.GRASS, 9, 0.35, 45, 50, 55, 30));
        POKEMON_RARITY.put("Oddish", 2);
        POKEMON_DB.put("Bellsprout", new PokemonData(PokemonType.GRASS, 10, 0.3, 50, 75, 35, 40));
        POKEMON_RARITY.put("Bellsprout", 2);

        // Normal
        POKEMON_DB.put("Eevee", new PokemonData(PokemonType.NORMAL, 9, 0.3, 55, 55, 50, 55));
        POKEMON_RARITY.put("Eevee", 3);
        POKEMON_DB.put("Jigglypuff", new PokemonData(PokemonType.FAIRY, 8, 0.4, 115, 45, 20, 20));
        POKEMON_RARITY.put("Jigglypuff", 1);
        POKEMON_DB.put("Meowth", new PokemonData(PokemonType.NORMAL, 10, 0.4, 40, 45, 35, 90));
        POKEMON_RARITY.put("Meowth", 1);
        POKEMON_DB.put("Snorlax", new PokemonData(PokemonType.NORMAL, 20, 0.1, 160, 110, 65, 30));
        POKEMON_RARITY.put("Snorlax", 3);

        // Fighting
        POKEMON_DB.put("Machop", new PokemonData(PokemonType.FIGHTING, 13, 0.25, 70, 80, 50, 35));
        POKEMON_RARITY.put("Machop", 4);

        // Ghost
        POKEMON_DB.put("Gastly", new PokemonData(PokemonType.GHOST, 15, 0.2, 30, 35, 30, 80));
        POKEMON_RARITY.put("Gastly", 3);
        POKEMON_DB.put("Haunter", new PokemonData(PokemonType.GHOST, 20, 0.15, 45, 50, 45, 95));
        POKEMON_RARITY.put("Haunter", 3);
        POKEMON_DB.put("Gengar", new PokemonData(PokemonType.GHOST, 25, 0.1, 60, 65, 60, 110));
        POKEMON_RARITY.put("Gengar", 4);
        POKEMON_DB.put("Misdreavus", new PokemonData(PokemonType.GHOST, 18, 0.2, 60, 60, 60, 85));
        POKEMON_RARITY.put("Misdreavus", 3);

        // Dragon/Psychic (rare)
        POKEMON_DB.put("Dragonite", new PokemonData(PokemonType.DRAGON, 30, 0.05, 91, 134, 95, 80));
        POKEMON_RARITY.put("Dragonite", 5);
        POKEMON_DB.put("Mewtwo", new PokemonData(PokemonType.PSYCHIC, 40, 0.01, 106, 110, 90, 130));
        POKEMON_RARITY.put("Mewtwo", 5);
    }

    public static void main(String[] args) {
        initializeGame();
        mainMenu();
        scanner.close();
    }

    private static void initializeGame() {
        // Get player name and coins
        String playerName = JOptionPane.showInputDialog("Please enter your name:");
        if (playerName == null || playerName.trim().isEmpty()) {
            playerName = "Trainer";
        }

        int defaultCoins = 100;
        try {
            String coinInput = JOptionPane.showInputDialog("Please enter your coin amount (default: 100)");
            coins = (coinInput == null || coinInput.trim().isEmpty()) ? 
                    defaultCoins : Integer.parseInt(coinInput);
            if (coins < 0) {
                JOptionPane.showMessageDialog(null, "Coin amount cannot be negative! Setting to 100.");
                coins = defaultCoins;
            }
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(null, "Invalid coin amount! Setting to 100.");
            coins = defaultCoins;
        }

        player = new Player(playerName);
        System.out.println("Welcome, " + playerName + "! You have " + coins + " coins.");
    }

    private static void mainMenu() {
        while (true) {
            System.out.println("\n====== MAIN MENU ======");
            System.out.println("1. Battle and Catch");
            System.out.println("2. View party");
            System.out.println("3. Manage Pokemon");
            System.out.println("4. View Top Scores");
            System.out.println("5. Save Game");
            System.out.println("6. Load Game");
            System.out.println("7. Exit");
            System.out.print("Choose an option: ");

            int choice = getIntInput(1, 7);
            switch (choice) {
                case 1 -> battleAndCatchMode();
                case 2 -> viewParty();
                case 3 -> managePokemon();
                case 4 -> displayTopScores();
                case 5 -> saveGame();
                case 6 -> loadGame();
                case 7 -> {
                    System.out.println("Thanks for playing!");
                    return;
                }
            }
        }
    }

    private static void battleAndCatchMode() {
        // Deduct 1 coin to play
        if (coins < 1) {
            System.out.println("You need at least 1 coin to play!");
            return;
        }

        coins--;
        System.out.println("\n1 coin has been used to enter the stage.");
        System.out.println("Remaining coins: " + coins);

        // Choose location with boosted Pokemon
        System.out.println("\n===== BATTLE STAGE SELECTION =====");
        System.out.println("1. Verdant Glade (Boosted: Charmander)");
        System.out.println("2. Whispering Woods (Boosted: Bulbasaur)");
        System.out.println("3. Crystal Lakefront (Boosted: Squirtle)");
        System.out.println("4. Haunted Mansion (Boosted: Gastly)");
        System.out.print("Choose a battle stage: ");

        int choice = getIntInput(1, 4);
        String[] locations = {"Verdant Glade", "Whispering Woods", "Crystal Lakefront", "Haunted Mansion"};
        String[] boostedPokemon = {"Charmander", "Bulbasaur", "Squirtle", "Gastly"};
        currentLocation = locations[choice - 1];
        String boostedName = boostedPokemon[choice - 1];

        System.out.println("\nYou've arrived at: " + currentLocation);
        System.out.println("This location has a higher chance to encounter " + boostedName + "!");

        // Catch Time - select from 3 random Pokemon
        System.out.println("\n=== CATCH TIME ===");
        List<Pokemon> encounterPool = generateRandomEncounters(3, boostedName);
        System.out.println("Choose a Pokemon to catch:");

        for (int i = 0; i < encounterPool.size(); i++) {
            System.out.println("\n[" + (i + 1) + "]");
            encounterPool.get(i).displayInfo();
            System.out.print("Rarity: ");
            for (int j = 0; j < POKEMON_RARITY.get(encounterPool.get(i).getName()); j++) {
                System.out.print("*");
            }
            System.out.println();
        }

        System.out.print("\nEnter your choice (1-3): ");
        int captureChoice = getIntInput(1, 3);
        Pokemon caught = encounterPool.get(captureChoice - 1);
        addPokemonToParty(caught.getName());

        // Battle sequence
        startBattleSequence();
    }

    private static List<Pokemon> generateRandomEncounters(int count, String boostedPokemon) {
        List<Pokemon> encounters = new ArrayList<>();
        List<String> pokemonNames = new ArrayList<>(POKEMON_DB.keySet());

        while (encounters.size() < count) {
            // Boosted chance for the location's featured Pokemon
            if (random.nextInt(100) < 30 && !containsPokemonByName(encounters, boostedPokemon)) {
                PokemonData data = POKEMON_DB.get(boostedPokemon);
                Pokemon pokemon = createPokemon(boostedPokemon, data);
                encounters.add(pokemon);
                continue;
            }

            // Regular random selection with rarity consideration
            int rarity = getRandomRarity(random.nextInt(100) + 1);
            List<String> candidates = new ArrayList<>();
            for (String name : pokemonNames) {
                if (POKEMON_RARITY.get(name) == rarity && !containsPokemonByName(encounters, name)) {
                    candidates.add(name);
                }
            }

            if (!candidates.isEmpty()) {
                String name = candidates.get(random.nextInt(candidates.size()));
                PokemonData data = POKEMON_DB.get(name);
                Pokemon pokemon = createPokemon(name, data);
                encounters.add(pokemon);
            }
        }
        return encounters;
    }

    private static Pokemon createPokemon(String name, PokemonData data) {
        switch (data.type) {
            case FIRE:
                return new FirePokemon(name, data.level, data.catchRate, data.baseHp, data.baseAttack, data.baseDefense, data.baseSpeed);
            case WATER:
                return new WaterPokemon(name, data.level, data.catchRate, data.baseHp, data.baseAttack, data.baseDefense, data.baseSpeed);
            case GRASS:
                return new GrassPokemon(name, data.level, data.catchRate, data.baseHp, data.baseAttack, data.baseDefense, data.baseSpeed);
            case ELECTRIC:
                return new ElectricPokemon(name, data.level, data.catchRate, data.baseHp, data.baseAttack, data.baseDefense, data.baseSpeed);
            case GHOST:
                return new GhostPokemon(name, data.level, data.catchRate, data.baseHp, data.baseAttack, data.baseDefense, data.baseSpeed);
            case FIGHTING:
                return new FightingPokemon(name, data.level, data.catchRate, data.baseHp, data.baseAttack, data.baseDefense, data.baseSpeed);
            case PSYCHIC:
                return new PsychicPokemon(name, data.level, data.catchRate, data.baseHp, data.baseAttack, data.baseDefense, data.baseSpeed);
            case DRAGON:
                return new DragonPokemon(name, data.level, data.catchRate, data.baseHp, data.baseAttack, data.baseDefense, data.baseSpeed);
            case FAIRY:
                return new FairyPokemon(name, data.level, data.catchRate, data.baseHp, data.baseAttack, data.baseDefense, data.baseSpeed);
            default:
                return new NormalPokemon(name, data.level, data.catchRate, data.baseHp, data.baseAttack, data.baseDefense, data.baseSpeed);
        }
    }

    private static boolean containsPokemonByName(List<Pokemon> list, String name) {
        for (Pokemon p : list) {
            if (p.getName().equals(name)) {
                return true;
            }
        }
        return false;
    }

    private static int getRandomRarity(int roll) {
        if (roll <= 5) return 5;      
        else if (roll <= 20) return 4; 
        else if (roll <= 40) return 3; 
        else if (roll <= 70) return 2; 
        else return 1;                 
    }

    private static void startBattleSequence() {
        if (player.getParty().isEmpty()) {
            System.out.println("You need at least 1 Pokemon in your party to battle!");
            return;
        }

        System.out.println("\n" + player.getName() + ", prepare for battle!");
        System.out.println("Choose your Pokemon:");
        List<Pokemon> party = player.getParty();

        for (int i = 0; i < party.size(); i++) {
            Pokemon p = party.get(i);
            System.out.println((i + 1) + ". " + p.getName() + 
                             " (Lvl " + p.getLevel() + " HP: " + 
                             p.getCurrentHp() + "/" + p.getMaxHp() + ")");
        }

        System.out.print("Enter your choice: ");
        int choice = getIntInput(1, party.size());
        Pokemon selected = party.get(choice - 1);

        // Check if Pokemon is defeated BEFORE proceeding
        if (selected.isDefeated()) {
            System.out.println(selected.getName() + " is too weak to battle! Please heal it first.");
            return;
        }

        System.out.println("\n" + selected.getName() + " is ready for battle!");

        // Generate opponent (with safety check)
        List<Pokemon> wildPokemon = generateRandomEncounters(1, "");
        if (wildPokemon.isEmpty()) {
            System.out.println("No wild Pokemon appeared! Try again.");
            return;
        }

        Pokemon opponent = wildPokemon.get(0);
        System.out.println("\nA wild " + opponent.getName() + " appeared!");

        // Start battle
        BattleSystem battle = new BattleSystem(
            Collections.singletonList(selected),
            Collections.singletonList(opponent)
        );
        battle.startBattle();

        // Post-battle logic
        if (battle.isPlayerVictorious()) {
            int battleScore = battle.getBattleScore();
            saveScore(battleScore);
            System.out.println("Battle Score: " + battleScore);
            int coinsEarned = battleScore / 10;
            coins += coinsEarned;
            System.out.println("Earned " + coinsEarned + " coins! Total coins: " + coins);
            if (!opponent.isDefeated()) {
                attemptCatch(opponent);
            }
        } else {
            System.out.println("You lost the battle! No coins earned.");
        }
    }
    static class PokeBall {
        private final String name;
        private final double catchModifier;

        public PokeBall(String name, double catchModifier) {
            this.name = name;
            this.catchModifier = catchModifier;
        }

        public String getName() {
            return name;
        }

        public double getCatchModifier() {
            return catchModifier;
        }
    }
    static class CatchSystem {
        public static boolean tryCatch(Pokemon pokemon, PokeBall ball) {
            double catchProbability = pokemon.getCatchRate() * ball.getCatchModifier();
            return Math.random() < catchProbability;
        }
    }

    private static void attemptCatch(Pokemon wildPokemon) {
        System.out.println("\nAttempt to catch " + wildPokemon.getName() + "?");
        System.out.println("1. Yes");
        System.out.println("2. No");
        System.out.print("Choose: ");

        int choice = getIntInput(1, 2);
        if (choice == 2) return;

        PokeBall[] balls = {
            new PokeBall("Poke Ball", 1.0),
            new PokeBall("Great Ball", 1.5),
            new PokeBall("Ultra Ball", 2.0),
            new PokeBall("Master Ball", 2.5)
        };

        System.out.println("\nChoose a Poke Ball:");
        for (int i = 0; i < balls.length; i++) {
            System.out.println((i + 1) + ". " + balls[i].getName() + 
                             " (Catch Rate Bonus: " + balls[i].getCatchModifier() + "x)");
        }

        int ballChoice = getIntInput(1, balls.length);
        PokeBall chosenBall = balls[ballChoice - 1];

        if (CatchSystem.tryCatch(wildPokemon, chosenBall)) {
            player.addPokemon(wildPokemon);
            System.out.println("Gotcha! " + wildPokemon.getName() + " was caught!");
        } 
        else {
            System.out.println("Oh no! " + wildPokemon.getName() + " broke free!");
        }
    }

    private static void addPokemonToParty(String name) {
        if (!POKEMON_DB.containsKey(name)) {
            System.out.println("Error: Unknown Pokemon " + name);
            return;
        }

        PokemonData data = POKEMON_DB.get(name);
        Pokemon newPokemon = createPokemon(name, data);
        player.addPokemon(newPokemon);
        System.out.println("\nYou captured: " + name + "!");
    }

    private static void viewParty() {
        System.out.println("\n===== YOUR POKEMON PARTY =====");
        List<Pokemon> party = player.getParty();

        if (party.isEmpty()) {
            System.out.println("You have no Pokemon in your party!");
            return;
        }

        for (int i = 0; i < party.size(); i++) {
            System.out.println("\nPokemon #" + (i + 1));
            party.get(i).displayDetailedInfo();
            System.out.println("Type Effectiveness:");
            System.out.println("Strong against: " + getStrongAgainst(party.get(i).getType()));
            System.out.println("Weak against: " + getWeakAgainst(party.get(i).getType()));
        }
    }

    private static String getStrongAgainst(PokemonType type) {
        switch (type) {
            case FIRE: 
            	return "Grass, Bug, Ice, Steel";
            case WATER: 
            	return "Fire, Rock, Ground";
            case GRASS: 
            	return "Water, Rock, Ground";
            case ELECTRIC: 
            	return "Water, Flying";
            case GHOST: 
            	return "Ghost, Psychic";
            case FAIRY: 
            	return "Fighting, Dragon, Dark";
            case FIGHTING: 
            	return "Normal, Rock, Ice, Dark";
            case PSYCHIC: 
            	return "Fighting, Poison";
            case DRAGON: 
            	return "Dragon";
            default: 
            	return "None";
        }
    }

    private static String getWeakAgainst(PokemonType type) {
        switch (type) {
            case FIRE: 
            	return "Water, Rock, Ground";
            case WATER: 
            	return "Grass, Electric";
            case GRASS: 
            	return "Fire, Flying, Poison, Bug, Ice";
            case ELECTRIC: 
            	return "Ground";
            case GHOST: 
            	return "Ghost, Dark";
            case FAIRY: 
            	return "Poison, Steel";
            case FIGHTING: 
            	return "Flying, Psychic, Fairy";
            case PSYCHIC: 
            	return "Bug, Ghost, Dark";
            case DRAGON: 
            	return "Ice, Dragon, Fairy";
            default: 
            	return "None";
        }
    }

    private static void managePokemon() {
        if (player.getParty().isEmpty()) {
            System.out.println("You have no Pokemon to manage!");
            return;
        }

        System.out.println("\n===== MANAGE POKEMON =====");
        List<Pokemon> party = player.getParty();

        for (int i = 0; i < party.size(); i++) {
            Pokemon p = party.get(i);
            System.out.printf("%d. %s (Lvl %d) HP: %d/%d\n",i+1, p.getName(), p.getLevel(), p.getCurrentHp(), p.getMaxHp());
        }

        System.out.print("Select Pokemon to manage (0 to cancel): ");
        int choice = getIntInput(0, party.size());
        if (choice == 0) return;

        Pokemon selected = party.get(choice - 1);
        System.out.println("\nSelected: " + selected.getName());
        System.out.println("1. Use Potion (restore 20 HP)");
        System.out.println("2. Send to PC");
        System.out.print("Choose action: ");

        int action = getIntInput(1, 2);
        if (action == 1) {
            selected.restoreHealth(20);
            System.out.println(selected.getName() + " restored 20 HP!");
        } 
        else {
            player.removePokemon(selected);
            System.out.println(selected.getName() + " sent to PC!");
        }
    }

    private static void saveScore(int score) {
        try {
            // Read existing scores
            List<Integer> scores = new ArrayList<>();
            if (new File(SCORES_FILE).exists()) {
                try (BufferedReader reader = new BufferedReader(new FileReader(SCORES_FILE))) {
                    String line;
                    while ((line = reader.readLine()) != null) {
                        scores.add(Integer.parseInt(line));
                    }
                }
            }
            scores.add(score);
            scores.sort(Collections.reverseOrder());
            if (scores.size() > 5) {
                scores = scores.subList(0, 5);
            }
            try (BufferedWriter writer = new BufferedWriter(new FileWriter(SCORES_FILE))) {
                for (Integer s : scores) {
                    writer.write(s.toString());
                    writer.newLine();
                }
            }
            System.out.println("Score saved!");
        } 
        catch (IOException e) {
            System.out.println("Error saving score: " + e.getMessage());
        }
    }

    private static void displayTopScores() {
        try {
            if (!new File(SCORES_FILE).exists()) {
                System.out.println("No scores recorded yet!");
                return;
            }

            System.out.println("\n===== TOP 5 SCORES =====");
            try (BufferedReader reader = new BufferedReader(new FileReader(SCORES_FILE))) {
                String line;
                int rank = 1;
                while ((line = reader.readLine()) != null && rank <= 5) {
                    System.out.println(rank + ". " + line);
                    rank++;
                }
            }
        } 
        catch (IOException e) {
            System.out.println("Error reading scores: " + e.getMessage());
        }
    }

    private static void saveGame() {
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(SAVE_FILE))) {
            GameData data = new GameData(player, coins, currentLocation);
            oos.writeObject(data);
            System.out.println("Game saved successfully!");
        }
        catch (IOException e) {
            System.out.println("Error saving game: " + e.getMessage());
        }
    }

    private static void loadGame() {
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(SAVE_FILE))) {
            GameData data = (GameData) ois.readObject();
            player = data.player;
            coins = data.coins;
            currentLocation = data.currentLocation;
            System.out.println("Game loaded successfully!");
            System.out.println("Welcome back, " + player.getName() + "!");
            System.out.println("Location: " + currentLocation);
            System.out.println("Coins: " + coins);
        } 
        catch (IOException | ClassNotFoundException e) {
            System.out.println("Error loading game: " + e.getMessage());
        }
    }

    private static int getIntInput(int min, int max) {
        int choice;
        while (true) {
            try {
                choice = scanner.nextInt();
                scanner.nextLine(); 
                if (choice >= min && choice <= max) break;
                System.out.print("Invalid input. Enter between " + min + "-" + max + ": ");
            } 
            catch (InputMismatchException e) {
                System.out.print("Invalid input. Enter a number: ");
                scanner.next();
            }
        }
        return choice;
    }

    // ===== SUPPORTING CLASSES =====

    enum PokemonType {FIRE, WATER, GRASS, ELECTRIC, NORMAL, FIGHTING, GHOST, FAIRY, PSYCHIC, DRAGON,BUG, ROCK, GROUND, FLYING, POISON, ICE, DARK, STEEL
    }

    static class PokemonData {
        PokemonType type;
        int level;
        double catchRate;
        int baseHp;
        int baseAttack;
        int baseDefense;
        int baseSpeed;

        public PokemonData(PokemonType type, int level, double catchRate,int baseHp, int baseAttack, int baseDefense, int baseSpeed) {
            this.type = type;
            this.level = level;
            this.catchRate = catchRate;
            this.baseHp = baseHp;
            this.baseAttack = baseAttack;
            this.baseDefense = baseDefense;
            this.baseSpeed = baseSpeed;
        }
    }

    static class GameData implements Serializable {
        private static final long serialVersionUID = 1L;
        final Player player;
        final int coins;
        final String currentLocation;

        public GameData(Player player, int coins, String currentLocation) {
            this.player = player;
            this.coins = coins;
            this.currentLocation = currentLocation;
        }
    }

    static class Player implements Serializable {
        private static final long serialVersionUID = 1L;
        private final String name;
        private final ArrayList<Pokemon> party;

        public Player(String name) {
            this.name = name;
            this.party = new ArrayList<>();
        }

        public void addPokemon(Pokemon pokemon) {
            if (party.size() < 6) {
                party.add(pokemon);
            } 
            else {
                System.out.println("Party is full! Would you like to send to PC or replace a Pokemon?");
                System.out.println("1. Send to PC");
                System.out.println("2. Replace a Pokemon");
                System.out.print("Choose: ");

                int choice = PokemonGame.getIntInput(1, 2);
                if (choice == 1) {
                    System.out.println(pokemon.getName() + " sent to PC!");
                } 
                else {
                    System.out.println("Select Pokemon to replace:");
                    for (int i = 0; i < party.size(); i++) {
                        System.out.println((i + 1) + ". " + party.get(i).getName());
                    }
                    int replaceChoice = PokemonGame.getIntInput(1, party.size());
                    Pokemon replaced = party.set(replaceChoice - 1, pokemon);
                    System.out.println(replaced.getName() + " was replaced with " + pokemon.getName());
                }
            }
        }

        public boolean removePokemon(Pokemon pokemon) {
            return party.remove(pokemon);
        }

        public ArrayList<Pokemon> getParty() {
            return party;
        }

        public String getName() {
            return name;
        }
    }

    static abstract class Pokemon implements Serializable {
        private static final long serialVersionUID = 1L;
        private final String name;
        private final PokemonType type;
        private final int level;
        private final double baseCatchRate;
        private final int maxHp;
        private int currentHp;
        private final int attack;
        private final int defense;
        private final int speed;

        public Pokemon(String name, PokemonType type, int level, double baseCatchRate,
                     int baseHp, int baseAttack, int baseDefense, int baseSpeed) {
            this.name = name;
            this.type = type;
            this.level = level;
            this.baseCatchRate = baseCatchRate;
            this.maxHp = baseHp + (level * 5);
            this.currentHp = this.maxHp;
            this.attack = baseAttack + (level * 2);
            this.defense = baseDefense + (level * 2);
            this.speed = baseSpeed + (level * 2);
        }

        // Abstract method for special abilities (polymorphism)
        public abstract void useSpecialAbility();
        public void displayInfo() {
            System.out.println("Name: " + name);
            System.out.println("Type: " + type);
            System.out.println("Level: " + level);
        }

        public void displayDetailedInfo() {
            displayInfo();
            System.out.println("HP: " + currentHp + "/" + maxHp);
            System.out.println("Attack: " + attack);
            System.out.println("Defense: " + defense);
            System.out.println("Speed: " + speed);
        }

        public String getName() { 
        	return name;
        	}
        public PokemonType getType() { 
        	return type;
        	}
        public int getCurrentHp() { 
        	return currentHp; 
        	}
        public int getMaxHp() { 
        	return maxHp; 
        	}
        public int getLevel() { 
        	return level;
        	}
        public int getAttack() { 
        	return attack; 
        	}
        public int getDefense() { 
        	return defense; 
        	}
        public int getSpeed() { 
        	return speed;
        	}

        public void takeDamage(int damage) {
            currentHp = Math.max(0, currentHp - damage);
        }

        public void restoreHealth(int amount) {
            currentHp = Math.min(maxHp, currentHp + amount);
        }

        public boolean isDefeated() {
            return currentHp <= 0;
        }

        public double getCatchRate() {
            double hpFactor = 1.0 - (double) currentHp / maxHp;
            return Math.min(1.0, baseCatchRate * (0.5 + hpFactor));
        }
    }

    @SuppressWarnings("serial")
	static class FirePokemon extends Pokemon {
        public FirePokemon(String name, int level, double baseCatchRate,int baseHp, int baseAttack, int baseDefense, int baseSpeed) {
            super(name, PokemonType.FIRE, level, baseCatchRate, baseHp, baseAttack, baseDefense, baseSpeed);
        }

        @Override
        public void useSpecialAbility() {
            System.out.println(getName() + " uses Fire Blast!");
        }
    }

    @SuppressWarnings("serial")
	static class WaterPokemon extends Pokemon {
        public WaterPokemon(String name, int level, double baseCatchRate,int baseHp, int baseAttack, int baseDefense, int baseSpeed) {
            super(name, PokemonType.WATER, level, baseCatchRate, baseHp, baseAttack, baseDefense, baseSpeed);
        }

        @Override
        public void useSpecialAbility() {
            System.out.println(getName() + " uses Hydro Pump!");
        }
    }

    @SuppressWarnings("serial")
	static class GrassPokemon extends Pokemon {
        public GrassPokemon(String name, int level, double baseCatchRate,int baseHp, int baseAttack, int baseDefense, int baseSpeed) {
            super(name, PokemonType.GRASS, level, baseCatchRate, baseHp, baseAttack, baseDefense, baseSpeed);
        }

        @Override
        public void useSpecialAbility() {
            System.out.println(getName() + " uses Solar Beam!");
        }
    }

    @SuppressWarnings("serial")
	static class ElectricPokemon extends Pokemon {
        public ElectricPokemon(String name, int level, double baseCatchRate,int baseHp, int baseAttack, int baseDefense, int baseSpeed) {
            super(name, PokemonType.ELECTRIC, level, baseCatchRate, baseHp, baseAttack, baseDefense, baseSpeed);
        }

        @Override
        public void useSpecialAbility() {
            System.out.println(getName() + " uses Thunderbolt!");
        }
    }

    @SuppressWarnings("serial")
	static class GhostPokemon extends Pokemon {
        public GhostPokemon(String name, int level, double baseCatchRate,int baseHp, int baseAttack, int baseDefense, int baseSpeed) {
            super(name, PokemonType.GHOST, level, baseCatchRate, baseHp, baseAttack, baseDefense, baseSpeed);
        }

        @Override
        public void useSpecialAbility() {
            System.out.println(getName() + " uses Shadow Ball!");
        }
    }

    @SuppressWarnings("serial")
	static class FightingPokemon extends Pokemon {
        public FightingPokemon(String name, int level, double baseCatchRate,int baseHp, int baseAttack, int baseDefense, int baseSpeed) {
            super(name, PokemonType.FIGHTING, level, baseCatchRate, baseHp, baseAttack, baseDefense, baseSpeed);
        }

        @Override
        public void useSpecialAbility() {
            System.out.println(getName() + " uses Close Combat!");
        }
    }

    @SuppressWarnings("serial")
	static class PsychicPokemon extends Pokemon {
        public PsychicPokemon(String name, int level, double baseCatchRate,int baseHp, int baseAttack, int baseDefense, int baseSpeed) {
            super(name, PokemonType.PSYCHIC, level, baseCatchRate, baseHp, baseAttack, baseDefense, baseSpeed);
        }

        @Override
        public void useSpecialAbility() {
            System.out.println(getName() + " uses Psychic!");
        }
    }

    @SuppressWarnings("serial")
	static class DragonPokemon extends Pokemon {
        public DragonPokemon(String name, int level, double baseCatchRate,int baseHp, int baseAttack, int baseDefense, int baseSpeed) {
            super(name, PokemonType.DRAGON, level, baseCatchRate, baseHp, baseAttack, baseDefense, baseSpeed);
        }

        @Override
        public void useSpecialAbility() {
            System.out.println(getName() + " uses Draco Meteor!");
        }
    }

    @SuppressWarnings("serial")
	static class NormalPokemon extends Pokemon {
        public NormalPokemon(String name, int level, double baseCatchRate,int baseHp, int baseAttack, int baseDefense, int baseSpeed) {
            super(name, PokemonType.NORMAL, level, baseCatchRate, baseHp, baseAttack, baseDefense, baseSpeed);
        }

        @Override
        public void useSpecialAbility() {
            System.out.println(getName() + " uses Hyper Beam!");


        }
    }

    @SuppressWarnings("serial")
	static class FairyPokemon extends Pokemon {
        public FairyPokemon(String name, int level, double baseCatchRate,int baseHp, int baseAttack, int baseDefense, int baseSpeed) {
            super(name, PokemonType.FAIRY, level, baseCatchRate, baseHp, baseAttack, baseDefense, baseSpeed);
        }

        @Override
        public void useSpecialAbility() {
            System.out.println(getName() + " uses Moonblast!");
        }
    }

    static class BattleSystem {
    private final List<Pokemon> playerTeam;
    private final List<Pokemon> opponentTeam;
    private int turnCount;
    private boolean battleEnded;
    private boolean playerVictorious;
    private boolean doubleRushActive;
    private int doubleRushTurns;
    private boolean rushComboActive;
    private int rushComboCount;
    private final Random random = new Random();

    public BattleSystem(List<Pokemon> playerTeam, List<Pokemon> opponentTeam) {
        this.playerTeam = new ArrayList<>(playerTeam);
        this.opponentTeam = new ArrayList<>(opponentTeam);
        this.turnCount = 0;
        this.battleEnded = false;
        this.playerVictorious = false;
        this.doubleRushActive = false;
        this.doubleRushTurns = 0;
        this.rushComboActive = false;
        this.rushComboCount = 0;
    }
    
    static class CatchSystem {
        public static boolean tryCatch(Pokemon pokemon, PokeBall ball) {
            double catchProbability = pokemon.getCatchRate() * ball.getCatchModifier();
            return Math.random() < catchProbability;
        }
    }
    
    static class PokeBall {
        private final String name;
        private final double catchModifier;
        
        public PokeBall(String name, double catchModifier) {
            this.name = name;
            this.catchModifier = catchModifier;
        }
        
        public String getName() {
            return name;
        }
        
        public double getCatchModifier() {
            return catchModifier;
        }
    }

    public void startBattle() {
        System.out.println("\n" + "=".repeat(40));
        System.out.println("⚔️ BATTLE STARTED! ⚔️");
        System.out.println("=".repeat(40));

        // Display initial status
        System.out.println("\nYOUR POKEMON:");
        playerTeam.forEach(p -> System.out.println(p.getName() + " HP: " + p.getCurrentHp() + "/" + p.getMaxHp()));
        System.out.println("\nWILD POKEMON:");
        opponentTeam.forEach(p -> System.out.println(p.getName() + " HP: " + p.getCurrentHp() + "/" + p.getMaxHp()));

        while (!battleEnded && !isTeamDefeated(playerTeam) && !isTeamDefeated(opponentTeam)) {
            turnCount++;
            System.out.println("\n--- Turn " + turnCount + " ---");

            checkBattleEvents();
            System.out.println("\nSpecial Abilities:");
            playerTeam.forEach(p -> {
                System.out.print("Your " + p.getName() + ": ");
                p.useSpecialAbility();
            });
            opponentTeam.forEach(p -> {
                System.out.print("Wild " + p.getName() + ": ");
                p.useSpecialAbility();
            });
            boolean playerFirst = playerTeam.get(0).getSpeed() >= opponentTeam.get(0).getSpeed();

            if (playerFirst) {
                playerTurn(playerTeam.get(0), opponentTeam.get(0));
                if (!battleEnded && !opponentTeam.get(0).isDefeated()) {
                    opponentTurn(opponentTeam.get(0), playerTeam.get(0));
                }
            } else {
                opponentTurn(opponentTeam.get(0), playerTeam.get(0));
                if (!battleEnded && !playerTeam.get(0).isDefeated()) {
                    playerTurn(playerTeam.get(0), opponentTeam.get(0));
                }
            }
            updateBattleEffects();
        }

        concludeBattle();
    }

    private void checkBattleEvents() {
        if (!doubleRushActive && random.nextDouble() < 0.2) {
            doubleRushActive = true;
            doubleRushTurns = 3;
            System.out.println("\n⚡ DOUBLE RUSH ACTIVATED! Attacks do double damage for 3 turns!");
        }

        // Check for Rush Combo activation (only if Double Rush is active)
        if (doubleRushActive && !rushComboActive && random.nextDouble() < 0.3) {
            rushComboActive = true;
            rushComboCount = 0;
            System.out.println("\n✨ RUSH COMBO ACTIVATED! Consecutive attacks increase damage!");
        }
    }

    private void updateBattleEffects() {
        // Decrement Double Rush turns if active
        if (doubleRushActive) {
            doubleRushTurns--;
            if (doubleRushTurns <= 0) {
                doubleRushActive = false;
                System.out.println("\nDouble Rush has ended.");
            }
        }

        if (rushComboActive) {
            rushComboCount = 0;
        }
    }

    private void playerTurn(Pokemon playerPokemon, Pokemon opponent) {
        System.out.println("\nYour " + playerPokemon.getName() + "'s turn:");
        System.out.println("1. Attack");
        System.out.println("2. Use Pokeball");
        System.out.println("3. Flee");
        System.out.print("Choose action: ");

        int choice = PokemonGame.getIntInput(1, 3);
        if (choice == 1) {
            attackSequence(playerPokemon, opponent, true);
            rushComboCount++; 
        } else if (choice == 2) {
            attemptCatch(opponent);
        } else {
            System.out.println("You fled from battle!");
            battleEnded = true;
        }
    }

    private void opponentTurn(Pokemon opponent, Pokemon playerPokemon) {
        System.out.println("\nWild " + opponent.getName() + "'s turn!");
        attackSequence(opponent, playerPokemon, false);
    }

    private void attackSequence(Pokemon attacker, Pokemon defender, boolean isPlayerAttack) {
        int baseDamage = 10 + (attacker.getLevel() * 2);
        int damage = random.nextInt(baseDamage / 2) + (baseDamage / 2);

        // Apply Double Rush if active
        if (doubleRushActive) {
            damage *= 2;
            System.out.println("Double Rush boosts the attack!");
        }

        // Apply Rush Combo if active (increases damage by 10% per consecutive attack)
        if (rushComboActive && isPlayerAttack) {
            double comboMultiplier = 1.0 + (0.1 * rushComboCount);
            damage = (int)(damage * comboMultiplier);
            System.out.println("Rush Combo x" + rushComboCount + " boosts damage by " + 
                             (int)((comboMultiplier - 1) * 100) + "%!");
        }

        // Apply type effectiveness
        double typeMultiplier = getTypeMultiplier(attacker.getType(), defender.getType());
        damage = (int)(damage * typeMultiplier);

        if (typeMultiplier > 1.0) {
            System.out.println("It's super effective!");
        } else if (typeMultiplier < 1.0) {
            System.out.println("It's not very effective...");
        }

        System.out.println(attacker.getName() + " attacks " + defender.getName() + 
                         " for " + damage + " damage!");
        defender.takeDamage(damage);

        if (defender.isDefeated()) {
            System.out.println(defender.getName() + " was defeated!");
        } else {
            System.out.println(defender.getName() + " HP: " + 
                             defender.getCurrentHp() + "/" + defender.getMaxHp());
        }
    }

    private double getTypeMultiplier(PokemonType attackerType, PokemonType defenderType) {
        // Expanded type effectiveness chart
        Map<PokemonType, List<PokemonType>> strengths = Map.of(
            PokemonType.FIRE, List.of(PokemonType.GRASS, PokemonType.BUG, PokemonType.ICE),
            PokemonType.WATER, List.of(PokemonType.FIRE, PokemonType.ROCK, PokemonType.GROUND),
            PokemonType.GRASS, List.of(PokemonType.WATER, PokemonType.ROCK, PokemonType.GROUND),
            PokemonType.ELECTRIC, List.of(PokemonType.WATER, PokemonType.FLYING),
            PokemonType.GHOST, List.of(PokemonType.GHOST, PokemonType.PSYCHIC),
            PokemonType.FIGHTING, List.of(PokemonType.NORMAL, PokemonType.ROCK, PokemonType.ICE, PokemonType.DARK),
            PokemonType.PSYCHIC, List.of(PokemonType.FIGHTING, PokemonType.POISON),
            PokemonType.DRAGON, List.of(PokemonType.DRAGON),
            PokemonType.FAIRY, List.of(PokemonType.FIGHTING, PokemonType.DRAGON, PokemonType.DARK)
        );

        Map<PokemonType, List<PokemonType>> weaknesses = Map.of(
            PokemonType.FIRE, List.of(PokemonType.WATER, PokemonType.ROCK, PokemonType.GROUND),
            PokemonType.WATER, List.of(PokemonType.GRASS, PokemonType.ELECTRIC),
            PokemonType.GRASS, List.of(PokemonType.FIRE, PokemonType.FLYING, PokemonType.POISON, PokemonType.BUG, PokemonType.ICE),
            PokemonType.ELECTRIC, List.of(PokemonType.GROUND),
            PokemonType.GHOST, List.of(PokemonType.GHOST, PokemonType.DARK),
            PokemonType.FIGHTING, List.of(PokemonType.FLYING, PokemonType.PSYCHIC, PokemonType.FAIRY),
            PokemonType.PSYCHIC, List.of(PokemonType.BUG, PokemonType.GHOST, PokemonType.DARK),
            PokemonType.DRAGON, List.of(PokemonType.ICE, PokemonType.DRAGON, PokemonType.FAIRY),
            PokemonType.FAIRY, List.of(PokemonType.POISON, PokemonType.STEEL)
        );

        if (strengths.getOrDefault(attackerType, List.of()).contains(defenderType)) {
            return 1.5;
        }
        if (weaknesses.getOrDefault(attackerType, List.of()).contains(defenderType)) {
            return 0.5;
        }
        return 1.0;
    }

    private void attemptCatch(Pokemon wildPokemon) {
        PokeBall[] balls = {
            new PokeBall("Poke Ball", 1.0),
            new PokeBall("Great Ball", 1.5),
            new PokeBall("Ultra Ball", 2.0),
            new PokeBall("Master Ball", 2.5)
        };

        System.out.println("\nChoose a Poke Ball:");
        for (int i = 0; i < balls.length; i++) {
            System.out.println((i + 1) + ". " + balls[i].getName());
        }

        int choice = PokemonGame.getIntInput(1, balls.length);
        PokeBall chosenBall = balls[choice - 1];

        if (CatchSystem.tryCatch(wildPokemon, chosenBall)) {
            PokemonGame.player.addPokemon(wildPokemon);
            battleEnded = true;
            playerVictorious = true;
        }
    }

    private boolean isTeamDefeated(List<Pokemon> team) {
        return team.stream().allMatch(Pokemon::isDefeated);
    }

    private void concludeBattle() {
        System.out.println("\n" + "=".repeat(40));
        System.out.println("⚔️ BATTLE ENDED ⚔️");

        if (isTeamDefeated(playerTeam)) {
            System.out.println("You lost the battle!");
        } 
        else if (isTeamDefeated(opponentTeam)) {
            System.out.println("You won the battle!");
            playerVictorious = true;
        }

        System.out.println("Battle lasted " + turnCount + " turns");
        System.out.println("=".repeat(40));
    }

    public boolean isPlayerVictorious() {
        return playerVictorious;
    }

    public int getBattleScore() {
        int score = 100 * turnCount;
        if (playerVictorious) score += 500;
        score += turnCount * 20;
        return score;
    	}
    }
}
